<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jsr-310 | It's SOAP's Fault...]]></title>
  <link href="http://blog.poznachowski.pl/categories/jsr-310/atom.xml" rel="self"/>
  <link href="http://blog.poznachowski.pl/"/>
  <updated>2016-06-15T17:23:54+02:00</updated>
  <id>http://blog.poznachowski.pl/</id>
  <author>
    <name><![CDATA[Grzegorz Poznachowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[@MockBean - Spring Boot's missing ingredient]]></title>
    <link href="http://blog.poznachowski.pl/2016/06/15/mockbean-spring-boot-missing-ingredient/"/>
    <updated>2016-06-15T00:00:00+02:00</updated>
    <id>http://blog.poznachowski.pl/2016/06/15/mockbean-spring-boot-missing-ingredient</id>
    <content type="html"><![CDATA[<p>I really liked the Spring Boot’s concept, since I first saw it.
The only thing, I felt, it was missing was a better support for testing in general.</p>

<h3 id="the-problem">The problem</h3>

<p>It all started, when I wanted to have a way to test ‘current date’ logic in my application.
It was supposed to be a reusable, easy-to-use feature (via an annotation) in a custom Spring Boot Starter.
The starter is based on Java 8, hence JSR-310 Date / Time API is a natural pick.
Current date is only one of several things I want to make “mockable” in integration tests.
There are other areas of functionality that are good candidates for mocking out.
Keeping that in mind, I will use <code>ZonedDateTime</code> class as a mocking example across the article.</p>

<h3 id="serving-current-date-in-jsr-310">Serving current date in JSR-310</h3>

<p>Java 8 comes with new, redesigned API for handling Date and Time.
It is designed after <em>Joda-Time</em>, but with many improvements and changes.
Here is a nice http://stackoverflow.com/questions/24631909/differences-between-java-8-date-time-api-java-time-and-joda-time[StackOverflow post]
pointing out most important ones.
One of nice features Joda-Time has, is <code>DateTimeUtils.setCurrentMillisFixed(long fixedMillis)</code>.
With that method I was able to set fixed current time easily and reset to system time by invoking <code>DateTimeUtils.setCurrentMillisSystem()</code>
after test execution.
However, it did not make through to Java 8 API.
Probably, due to the fact, that Joda-Time implementation of the functionality was kind of hackish.
Shared, static variable is used there for keeping <code>MillisProvider</code> instance.</p>

<p>How to achieve the same with JSR-310?
Most easy and basic way is to invoke <code>ZonedDateTime.now()</code>.
However, it would be bad from testing perspective.
How would you test that?
There are two more overloaded <code>now</code> methods and we are mostly interested in <code>now(Clock clock)</code>.
It’s Javadoc confirms that we are in the right place:</p>

<p>[quote, ZonedDateTime.now(Clock clock) Javadoc]
<em>__</em>
Obtains the current date-time from the specified clock.</p>

<p>This will query the specified clock to obtain the current date-time. +
The zone and offset will be set based on the time-zone in the clock.</p>

<p><em>Using this method allows the use of an alternate clock for testing. +
The alternate clock may be introduced using dependency injection.</em></p>

<p>@param clock  the clock to use, not null +
@return the current date-time, not null
<em>__</em></p>

<p>Ok, so now we need <code>Clock</code> instance to pass in.
How to get it?
Second part of the Javadoc highlighted text has the answer.
Treat it as a normal dependency and use dependency injection for that.
Hence, the easiest way is to declare a <code>Clock</code> bean in your application:</p>

<p>[source,java,indent=0]
.Specyfing Clock bean
—-
    @Bean
    public Clock clock() {
        return Clock.systemDefaultZone();
    }
—-</p>

<p>and use it as a regular dependency.</p>

<h1 id="tip">[TIP]</h1>
<p>Since https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3[Spring 4.3.RC1] you don’t need
to put <code>@Autowired</code> annotation with a single constructor class.
So, if you use https://projectlombok.org/[Lombok] and constructor injection (you always should!), you can reduce your initial code to:</p>

<h2 id="sourcejavaindent0">[source,java,indent=0]</h2>
<pre><code>@Service
@AllArgsConstructor
public class ClockService {
    private final Clock clock;
} ----
</code></pre>

<h1 id="spring-boot-supports-this-since-httpsgithubcomspring-projectsspring-bootissues5616140m2">Spring Boot supports this since https://github.com/spring-projects/spring-boot/issues/5616[1.4.0.M2].</h1>

<h3 id="before-spring-boot-140m2">Before Spring Boot 1.4.0.M2</h3>

<p>It’s time for the main course.
How we are going to test current date backed up with injected <code>Clock</code>?</p>

<p>The simplest solution I thought about was to use <code>@Primary</code>:</p>

<p>[source,java,indent=0]
.Specifying primary bean
—-
    @Bean
    @Primary
    public Clock clock() {
        return Clock.fixed(Instant.parse(“2010-01-10T10:00:00Z”), ZoneId.of(“UTC”));
    }
—-</p>

<p>Primary beans are always prefered and picked in a situation where 2 or more beans of the same type are found.
It works just fine for a single test case, but if you wanted to reuse it among your test classes,
you would need to copy this definition over and over.
One can extract it to a super class and use inheritance.
I find such solution a design smell.
If there are more candidates to mock, several artificial classes has to be created along with an inheritance tree, which would
obscure the test code.</p>

<p>As stated before, the solution is going to be a part of a custom Spring Boot starter.
Because of that, I was determined to make <code>Clock</code> mocking mechanism annotation based.
My first idea was to use <code>@ContextConfiguration</code> in my custom annotations, which would call configuration
of mocked <code>Clock</code> with <code>@Primary</code>.
After few attempts my lack of Spring knowledge came out.
Fortunately, Sam Brannen answered my question and http://stackoverflow.com/questions/35733344/can-contextconfiguration-in-a-custom-annotation-be-merged[explained it nicely].
Next approach was to incorporate Spring profiles.
In my test starter I have added profile specific configuration with <code>@Primary</code> mocked out bean dependencies.</p>

<p>[source, java, indent=0]
.Profile specific auto-configuration
—-
@Profile(“fixedClock”)
@Configuration
public class FixedClockAutoConfiguration {
}
—-</p>

<p>To use them I had to run my integration tests with corresponding profiles via <code>@ActiveProfiles</code>.
There were two major drawbacks I didn’t like with the solution:</p>

<ul>
  <li>Active profiles names had to be provided explicitly, that would mean remembering all available profile names.</li>
  <li>Mocked clock has some default value. I wanted to provide an option to override this value.
That was possible via <code>@TestPropertySource</code>, but again, property name had to be remembered.</li>
</ul>

<p>Was there anything else I could do, but I’m just not aware of?
Eventually, Phil Webb http://stackoverflow.com/questions/35848467/spring-boot-integration-test-doubles-by-annotations[clarified that Spring Boot 1.3 does not have the tools] I’m looking for.
With the bad news he brought, he brought also hope…
Spring Boot 1.4 is supposed to bring heavy testing enhancements.
Simplified annotation naming, focused testing (on JSON, MVC or JPA slices) and desired mocking support.</p>

<p>I had to wait… and for the time being, I did a slight improvement over my profiles.
I created a simple implementation of <code>ActiveProfilesResolver</code>, which enables picking proper profile via an annotation:</p>

<p>[source, java, indent=0]
.Example active profile resolver
—-
public class TestProfilesResolver implements ActiveProfilesResolver {</p>

<pre><code>ImmutableMap&lt;Class&lt;? extends Annotation&gt;, String&gt; PROFILES = ImmutableMap.&lt;Class&lt;? extends Annotation&gt;, String&gt;builder()
        .put(Wiremock.class, "wireMock")
        .put(FixedClock.class, "fixedClock")
        .build();

@Override
public String[] resolve(Class&lt;?&gt; testClass) {
    List&lt;String&gt; profiles = Lists.newArrayList();
    Arrays.stream(testClass.getAnnotations()).forEach(annotation -&gt; {
        Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();
        if (PROFILES.containsKey(annotationType)) {
            profiles.add(PROFILES.get(annotationType));
        }
    });
    return profiles.toArray(new String[profiles.size()]);
} } ----
</code></pre>

<p>To use it, annotate your integration test with <code>@ActiveProfiles(resolver = TestProfilesResolver.class)</code>.</p>

<p>It worked, but it had to be a part of the application and not a part of the starters I was preparing.
Reason for that are mock candidates - located in many different starters.
Without hardcoding all of them in a single one, it wouldn’t be particularly easy to accomplish.</p>

<h3 id="do-it-like-a-boss">Do it like a boss</h3>

<p>Ok, so all https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4[the goodies are in place] - Spring Boot 1.4.0.M2 is out for some time now.
Mockito support included.
All tutorials and
http://docs.spring.io/spring-boot/docs/1.4.0.M2/reference/htmlsingle/#boot-features-testing-spring-boot-applications-mocking-beans[documentation]
shows, however, only the basic usage of
<code>https://github.com/spring-projects/spring-boot/blob/c167e4fd0e834dedf0fd3c55a026e5671c6f4e7f/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/MockBean.java[@MockBean]</code>
annotation.
Which is specifying the annotation on a class field and using Mockito methods directly in the test class:</p>

<p>[source,java,indentation=0]
.Example @MockBean usage
—-
@RunWith(SpringRunner.class)
@SpringBootTest
public class MockBeanIntegrationTest {</p>

<pre><code>@MockBean
private SomeService someService;

@Before
public void setupMock() {
    when(someService.getResult())
        .thenReturn("success");
} } ----
</code></pre>

<p>With this in place, <code>SomeService</code> dependency is mocked out and set up to return “success” String anytime <code>getResult()</code> is invoked.
Mocks are reset after each test method by default.
There is also analogical support for spying beans via <code>@SpyBean</code> annotation.
It all works great, but there is more to that!</p>

<p><code>@MockBean</code>, implemented as meta-annotation, combined with <code>TestExecutionListener</code> is something I was looking for the whole time.
The idea is simple - create annotation that would indicate mocking particular dependency and handle mocking internals in the execution
listener:</p>

<p>First thing we can do is define our annotation.</p>

<h2 id="sourcejavaindentation0">[source,java,indentation=0]</h2>
<p>@Documented
@Inherited
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@MockBean(value = Clock.class, reset = MockReset.NONE) &lt;1&gt;
public @interface FixedClock {
    String value() default “2010-01-10T10:00:00Z”;
}
—-</p>

<p>&lt;1&gt; This is the only interesting part here.
Anytime you annotate your test with <code>@FixedClock</code>, it substitutes application context’s Clock-type bean with a mock.
We are disabling mock reset deliberately - it will be handled by the <code>TestExecutionListener</code>.</p>

<p><code>https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/TestExecutionListener.java[TestExecutionListener]</code>
is a feature in spring-test component, that allows to plug ‘Spring context’-aware custom code in JUnit test lifecycle phases.
As explained in http://docs.spring.io/spring/docs/4.3.0.RELEASE/spring-framework-reference/htmlsingle/#testcontext-tel-config[documentation],
there are couple of default listeners registered.
You can use your own by using <code>@TestExecutionListeners</code> annotation on a given test, but a better way is to
register it automatically via <code>META-INF/spring.factories</code> properties
(under <code>org.springframework.test.context.TestExecutionListener</code> key).
If order of your listeners is important you can easily assign the order value by implementing <code>Ordered</code> or by
annotating your listener with <code>@Order</code>.</p>

<p>TestExecutionListener interface has couple of methods:
[source,java,indentation=0]
—-
public interface TestExecutionListener {
    void beforeTestClass(TestContext testContext) throws Exception;
    void prepareTestInstance(TestContext testContext) throws Exception;
    void beforeTestMethod(TestContext testContext) throws Exception;
    void afterTestMethod(TestContext testContext) throws Exception;
    void afterTestClass(TestContext testContext) throws Exception;
}
—-</p>

<h1 id="tip-1">[TIP]</h1>
<p>If you don’t want to implement all of them, you can help yourself with <code>https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/support/AbstractTestExecutionListener.java[AbstractTestExecutionListener]</code> class,
which provides empty method stubs.
====</p>

<p>Let’s see how our <code>FixedClockListener</code> can implement these methods:</p>

<h2 id="sourcejavaindentation0-1">[source,java,indentation=0]</h2>
<p>public class FixedClockListener extends AbstractTestExecutionListener {</p>

<pre><code>@Override
public void beforeTestClass(TestContext testContext) throws Exception {
    FixedClock classFixedClock = AnnotationUtils.findAnnotation(testContext.getTestClass(), FixedClock.class); &lt;1&gt;
    if (classFixedClock == null) {
        return;
    }
    mockClock(testContext, classFixedClock); &lt;2&gt;
}

@Override
public void beforeTestMethod(TestContext testContext) throws Exception {
    FixedClock methodFixedClock = AnnotationUtils.findAnnotation(testContext.getTestMethod(), FixedClock.class); &lt;6&gt;
    if (methodFixedClock == null) {
        return;
    }
    verifyClassAnnotation(testContext); &lt;7&gt;
    mockClock(testContext, methodFixedClock);
}

@Override
public void afterTestMethod(TestContext testContext) throws Exception {
    FixedClock methodFixedClock = AnnotationUtils.findAnnotation(testContext.getTestMethod(), FixedClock.class);
    if (methodFixedClock == null) {
        return;
    }
    verifyClassAnnotation(testContext);

    FixedClock classFixedClock = AnnotationUtils.findAnnotation(testContext.getTestClass(), FixedClock.class); &lt;8&gt;
    mockClock(testContext, classFixedClock);
}

@Override
public void afterTestClass(TestContext testContext) throws Exception {
    FixedClock annotation = AnnotationUtils.findAnnotation(testContext.getTestClass(), FixedClock.class);
    if (annotation == null) {
        return;
    }
    reset(testContext.getApplicationContext().getBean(Clock.class)); &lt;9&gt;
}

private void verifyClassAnnotation(TestContext testContext) {
    FixedClock classAnnotation = AnnotationUtils.findAnnotation(testContext.getTestClass(), FixedClock.class);
    if (classAnnotation == null) {
        throw new IllegalStateException("@FixedClock class level annotation is missing.");
    }
}

private void mockClock(TestContext testContext, FixedClock fixedClock) {
    Instant instant = Instant.parse(fixedClock.value()); &lt;3&gt;
    Clock mockedClock = testContext.getApplicationContext().getBean(Clock.class); &lt;4&gt;
    when(mockedClock.instant()).thenReturn(instant); &lt;5&gt;
    when(mockedClock.getZone()).thenReturn(TimeZone.getDefault().toZoneId());
} } ----
</code></pre>

<p>&lt;1&gt; Simple check if a test class is annotated with our annotation. If not - skip further processing.
Prefer <code>AnnotationUtils.findAnnotation()</code> over simple <code>testClass().getAnnotations()</code> if you want to allow your annotation
to be a part of different, composed annotation.
&lt;2&gt; Extracted method for setting up our mock.
&lt;3&gt; Retrieved <code>Instant</code> object out of our annotation.
Will be used as a mock stub value.
&lt;4&gt; <code>Clock</code> bean is mocked by <code>@FixedClock</code> annotation and here we are fetching the mock from the application context,
so we can provide mocking stubs on the mock instance.
&lt;5&gt; Here we provide the stubs. As they has to be declared on method calls, we cannot simply just declare <code>Clock.fixed()</code> here.
Fortunately, there are only two methods to stub: <code>instant()</code>, and <code>getZone()</code>.
&lt;6&gt; With test execution listener approach, we can handle overriden fixed Clock values per test method.
Here again, a simple check if the method is in fact annotated.
If not - skip processing.
&lt;7&gt; For test methods, we need to implement additional verification step.
We need to check if the test class was annotated as well. <code>@MockBean</code> will work only if test class was marked with it.
&lt;8&gt; After test method execution, revert mock stub to what was specified globally (per test class).
&lt;9&gt; Eventually, when all tests ran, reset the mock.</p>

<p>With all we did so far, we can easily test code below:</p>

<h2 id="source-java-indentation0">[source, java, indentation=0]</h2>
<p>@RestController(“/api/time”)
@AllArgsConstructor
public class TimeEndpoint {
    private final Clock clock;</p>

<pre><code>@GetMapping
public ZonedDateTime getTime() {
    return ZonedDateTime.now(clock);
} } ----
</code></pre>

<p>and provide fixed current time in integration test:</p>

<h2 id="sourcejavaindentation0-2">[source,java,indentation=0]</h2>
<p>@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixedClock
public class FixedClockTest {</p>

<pre><code>@LocalServerPort
int port;

@Before
public void setUp() {
    RestAssured.port = this.port;
}

@Test
public void testClock() throws Exception {
    get("/api/time")
    .then()
        .body(containsString("2010-01-10T10:00:00Z")); // default @FixedClock value

}

@Test
@FixedClock("2011-11-11T11:00:00Z")
public void testClockOverridden() throws Exception {
    get("/api/time")
    .then()
        .body(containsString("2011-11-11T11:00:00Z"));

} } ----
</code></pre>

<h3 id="summary">Summary</h3>

<p>At last, it seems, that Spring Boot with 1.4.0.M2 release, received last, missing piece in its testing toolbox. +
Proposed solution will not only suit in a custom starter (but it’s a great fit).
You can implement similar solution in the actual application and you don’t have to limit yourself to mocking current date.
This approach let you mock anything you find appropriate, keeping your tests clean.</p>

<h1 id="note">[NOTE]</h1>
<p>Presented code samples are part of https://github.com/neoteric-eu/neo-starters[Neo-Starters] - even more opinionated way of developing REST services :)
====</p>
]]></content>
  </entry>
  
</feed>
